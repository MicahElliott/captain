#! /bin/zsh

# capt: a very simple git-hook manager

# Symbols fer usin:  ⚔ ⚳ ⚑ ☁ ☀ ✓ ◴◵◶◷

autoload colors; colors

# Save the incoming git-hook arg(s)
GITARG1=$argv[2] GITARG2=$argv[3] GITARG3=$argv[4]

dbg() { [[ -n $CAPT_VERBOSE ]] && print "$fg[cyan]DEBUG:" $@ $reset_color }
# aye() { print '(◕‿-)' $@ }
aye()  { print "$fg_bold[blue](◕‿-)$reset_color" $@ }
ayen() { print -n "$fg_bold[blue](◕‿-)$reset_color" $@ } # no newline

reporoot=$(git rev-parse --show-toplevel 2>/dev/null)
if [[ $? -ne 0 ]]; then
    aye "Captain must be run from the root of a git repo."; exit 1
elif [[ $reporoot != $PWD ]]; then
    aye "Captain only runs from yer repo root: $reporoot"; exit 1
fi

if [[ $#@ < 1 ]]; then
    aye 'Captain needs an arrrg! Try passing a git-hook name, like "pre-commit".'; exit 1
fi

print_banner() {
    # print '(◕‿-) Shiver me timbers!'
    # print ""
    print
    # aye "$fg_bold[white][$(date +%T)] $fg_bold[blue]=== ${(U)active_githook} ===$reset_color ${bold_color}CAPTAIN IS OVERHAULIN. NO QUARTER!$reset_color"
    print -n "$fg_bold[blue](◕‿-)$reset_color" \
          "$fg_bold[blue]☠☠☠ ${(U)active_githook} ☠☠☠$reset_color" \
          "$fg_bold[white][◷ $(date +%T)]"
    # aye "$bold_color=== ${(U)active_githook} ===$reset_color\n"
    # print '       _________ '
    # print '      |-_ .-. _-|'
    # print '      |  (*^*)  |'
    # print '      |_-"|H|"-_|'
    # print
}

hooksdir=${CAPT_HOOKSDIR-.git/hooks}
scriptsdir=${CAPT_SCRIPTSDIR-.capt/scripts}
# captfile=${CAPT_FILE-capt.zsh}
captfile=${CAPT_FILE-.capt/share.sh}
# captfilelocal=${CAPT_LOCALFILE-captlocal.zsh}
captfilelocal=${CAPT_LOCALFILE-.capt/local.sh}
path+=$scriptsdir

if [[ ! -f $captfile ]]; then print "Unable to load CAPT_FILE $captfile"; exit 1; fi

active_githook=$1
if [[ -z $active_githook ]]; then
    print "no hook configured in $captfile or $captfilelocal for $1"
    # exit
else
    print "ok got an active_githook: $active_githook"
fi

# Built-in convenience checkers
# keys are for lookups
# values are an optional filter, followed by a command to run
typeset -A builtin_cannons=(
    'markdownlint' '(md|mkd|markdown)mdl'
    'kondo'        '(clj|cljc|cljs)clj-kondo'
    # 'gommit'       'gommit check message "$(cat $1)"'
    'msglint'      'msglint "$(cat $GITARG1)"'
    'cljfmt'       '(clj)cljfmt check'
)

# Set up vars to be available in proj capt.zsh, print which files changed
setup_changes() {
    # VALUEADD Magic to figure out main v master and get changed files
    if [[ -z $CAPT_MAIN_BRANCH ]]; then
        # Fast and inaccurate https://stackoverflow.com/a/50056710/326516
        # main_branch=$(git branch | grep '*' | cut -f2 -d' ')
        # https://stackoverflow.com/a/42570510/326516
        # main_branch=$(git branch -r --points-at refs/remotes/origin/HEAD | grep '\->' | cut -d' ' -f5 | cut -d/ -f2)
        # https://stackoverflow.com/a/49384283/326516
        main_branch=$(git symbolic-ref --short refs/remotes/origin/HEAD | sed 's@^origin/@@')
    fi
    if [[ ! $main_branch == (main|master) ]]; then
        # This approach is better but slow to reach remote so like to avoid
        aye "\nDiscoverin yer MAIN branch remotely, since couldn't determine locally."
        aye "You could set CAPT_MAIN_BRANCH to avoid the stall."
        # https://stackoverflow.com/a/67170894/326516SX
        aye "You should also run this registration since your repo is not a clone:"
        aye "git remote set-head origin -a"
        main_branch=$(git remote show origin | sed -n '/HEAD branch/s/.*: //p')
    fi
    dbg "main_branch: $main_branch"
    # aye "Branch yer changes are bein compared against: $bold_color$main_branch$reset_color"
    print -n " $fg_bold[magenta][⎇ $main_branch]$reset_color"
    # CAPT_FILES_CHANGED=( $(git diff --name-only --cached origin/$main_branch) )
    CAPT_FILES_CHANGED=( $(git diff --name-only --cached $main_branch) )
    # aye "[Δ Staged files changed ($#CAPT_FILES_CHANGED)]: $bold_color$CAPT_FILES_CHANGED$reset_color"
    (( $#CAPT_FILES_CHANGED > 0 )) &&
        print " $fg_bold[yellow][Δ($#CAPT_FILES_CHANGED) $CAPT_FILES_CHANGED]$reset_color"
    # for f in $CAPT_FILES_CHANGED; do aye "- $bold_color$f$reset_color"; done
    # print
}

capt_play_alert() {
    if [[ $OSTYPE = linux-gnu ]]; then
        player=play
    elif [[ $OSTYPE =~ darwin ]]; then
        player=afplay
    else
        aye "Can't find audio player for alerting; falling back to beep."
        player=beep
    fi
    $player $@ }

# Run the scripts from control file
run_scripts () {
    # FIXME maybe all the vars (CAPT_FILES_CHANGED etc) should be local since getting reset on every call?
    # TODO check for existence of specified hook and print meaningful message if no/empty hook
    if [[ -z $@ ]]; then aye "No hooks to be run."; return; fi
    # Print out all the scripts about to be run
    executors=()
    for line in $@; do
        [[ $line == *:* ]] &&
            executors+="$fg_bold[grey]${${(@s/:/)line}[1]}$reset_color" ||
            executors+="$fg_bold[grey]$line$reset_color"
    done
    # print; aye "$fg_bold[cyan][$runlevel]$reset_color Execution awaits! $executors"
    # printf '\xc'; print "" # no luck with printing line for pagebreak/formfeed in magit
    print; aye "$fg_bold[cyan]☁☁☁ $runlevel ☁☁☁$reset_color $fg_bold[grey][⚳ $executors]$reset_color"

    # for line in $@; do
    #     [[ $line == *:* ]] &&
    #         aye "- $bold_color${${(@s/:/)line}[1]}$reset_color" ||
    #         aye "- $bold_color$line$reset_color"
    # done

    for line in $@; do
        inv=( ${(@s: :)line} ) # split on spaces to get first, discard beyond second
        name=$inv[1]
        script=$inv[2]
        cmd=${line#* } # remove up to first space, keeping all the rest
        dbg "inv:" $inv[1] "::" $inv[2] "::" $inv[3] "::"
        cmd0=${cmd%% *} # keep only first part, the command name
        dbg "line: $line :: cmd0: $cmd0 :: cmd: $cmd"

        # Built-in has filter already, or specified filter
        print_name=$(sed 's/[:(].*//' <<<$name)
        # print
        ayen "$fg[yellow]⚳⚳⚳ ${(U)print_name} ⚳⚳⚳$reset_color"
        if [[ ! $name == *: ]]; then dbg "built-in plain checker with no spec:" $name
            # Need to fix up cmd since no spec, and maybe include filtered files
            script=$inv[1]
            just_buitins=${(k)builtin_cannons}
            if ! (($just_buitins[(Ie)$name])); then aye "WARNING: Unable to find built-in:" $name; exit 1; fi
            #              NAME        FILTER    CMD
            # User spec is like:    markdownlint(md|mkd): mdl ...
            # DSL is actually like: (md|mkd)mdl ...
            dsl=$builtin_cannons[$name]
            filter=$(sed 's/).*/)/' <<<$dsl)
            # non-greedy, just the very first part up to (, and remove ending arg(s)
            cmd=$(sed -r -e 's/^\([^)]+\)//' <<<$dsl)
            cmd0=$(sed -r 's/ .*//' <<<$cmd)
            dbg "cmd0: "$cmd0
            # filtered_files=( $(grep -E "\.$builtin_cannons[$name]" <<<$CAPT_FILES_CHANGED) )
            filtered_files=( $(grep -E "\.$filter" <<<$CAPT_FILES_CHANGED) )
            if [[ $active_githook =~ 'commit-msg' ]]; then
                :
            elif [[ $#filtered_files < 1 ]]; then print " (Not seein any matchin files staged, skippin.)"; continue
            else
                cmd="$cmd0 $filtered_files"
                # print; aye "Filtered files under siege:" $#filtered_files
                print " $fg[yellow][$filtered_files]$reset_color"
                dbg "files:" $filtered_files
                aye "Ahoy! Aimin the captain’s built-in $print_name: $bold_color$cmd$reset_color"
            fi
        elif [[ $name == *\(*\)* ]]; then dbg "filtered checker"
            filter=$(sed 's/.*(/(/;s/://' <<<$name) # remove front name and trailing :
            dbg filter: $filter
            dbg CAPT_FILES_CHANGED: $CAPT_FILES_CHANGED
            filtered_files=( $(print -l $CAPT_FILES_CHANGED | grep -E "\.$filter") )
            CAPT_FILES_CHANGED=( $filtered_files )
            if [[ $#filtered_files < 1 ]]; then print " (Not seein any matchin files staged, skippin.)"; continue
            else
                # print; aye "Filtered files under siege:" $#filtered_files
                print " $fg[yellow][$filtered_files]$reset_color"
                dbg "files:" $filtered_files
                aye "Blimey! Aimin yer custom-rigged $print_name: $bold_color$cmd$reset_color"
            fi
        elif [[ $line == *CAPT_FILES_CHANGED* || ! $name == *: ]]; then dbg "unfiltered checker"
            filtered_files=( $CAPT_FILES_CHANGED )
            if [[ $#filtered_files < 1 ]]; then print " (Not seein any matchin files staged, skippin.)"; continue
            else
                # print; aye "Files under siege:" $#CAPT_FILES_CHANGED
                print " $fg[yellow][$CAPT_FILES_CHANGED]$reset_color"
                dbg "files:" $CAPT_FILES_CHANGED
                aye "Aimin yer cutlass $print_name with yer files: $bold_color$cmd$reset_color"
            fi
        else
            # print; aye "Ye took care of file selection yerself, or no files needin fer sayin."
            print " $fg[yellow][∞]$reset_color"
            aye "Doubloons! Aimin yer $print_name: $bold_color$cmd$reset_color"
        fi

        # Add args to pass from git if it's one of the arg-accepting hooks
        # [[ $active_githook =~ 'commit-msg' ]] && cmd+=' $1 $2'
        t0=$(date +%s%3N) # start timer
        # Work with either a local script or something found on path
        dbg "cmd: $cmd, cmd0: $cmd0"
        dbg "script: $scriptsdir/$script"
        # Try to find script or command
        if [[ -f $scriptsdir/$script ]]; then eval $scriptsdir/$cmd
        elif type $cmd0 >/dev/null;      then eval $cmd
        # Just skip this one hook if command not found
        else aye "WARNING: Skippin on yer $name; $cmd0 and $script be lost at sea."
        fi
        es=$?
        wait # don't process until background scripts are finished
        tfinal=$(( $(date +%s%3N) - $t0 )) units=ms units_color=white
        if (( 1000 < $tfinal )); then tfinal=$(( $tfinal / 1000 )); units=s; units_color=red; fi
        # Bail out on whole run if any script not successful
        if [[ $es -ne 0 ]]; then
            print
            print "$fg[red]    ⠀⠀⠀⠀⠀⠀⠀⠀⣀⣤⣤⣤⣤⣀⡀⠀⠀⠀⠀⠀⠀⠀"
            print "$fg[red]    ⠀⠀⠀⠀⠀⢀⣴⣿⣿⣿⡿⢿⣿⣿⣿⣷⣄⠀⠀⠀⠀⠀"
            print "$fg[red]    ⠀⣠⣤⣶⣶⣿⣿⣿⣿⣯⠀⠀⣽⣿⣿⣿⣿⣷⣶⣤⣄⠀"
            print "$fg[red]    ⢸⣿⣿⣿⣿⣿⣿⣿⣿⡅⠉⠉⢨⣿⣿⣿⣿⣿⣿⣿⣿⡇"
            print "$fg[red]    ⠈⠻⣿⣿⣿⣿⣿⣿⣿⣥⣴⣦⣬⣿⣿⣿⣿⣿⣿⣿⠟⠁"
            print "$fg[red]    ⠀⠀⢸⣿⡿⠿⠿⠿⠿⠿⠿⠿⢿⣿⣿⣿⠿⢿⣿⡇⠀⠀"
            print "$fg[red]    ⠀⣠⣾⣿⠂⠀⠀⣤⣄⠀⠀⢰⣿⣿⣿⣿⡆⠐⣿⣷⣄⠀"
            print "$fg[red]    ⠀⣿⣿⡀⠀⠀⠈⠿⠟⠀⠀⠈⠻⣿⣿⡿⠃⠀⢀⣿⣿⠀"
            print "$fg[red]    ⠀⠘⠻⢿⣷⡀⠀⠀⠀⢀⣀⣀⠀⠀⠀⠀⢀⣾⡿⠟⠃⠀"
            print "$fg[red]    ⠀⠀⠀⠸⣿⣿⣷⣦⣾⣿⣿⣿⣿⣦⣴⣾⣿⣿⡇⠀⠀⠀Down to Davey Jones’ locker!"
            print "$fg[red]    ⠀⠀⠀⠀⢻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠀⠀⠀⠀Status:" $es
            print "$fg[red]    ⠀⠀⠀⠀⠈⠻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠟⠁⠀⠀⠀⠀"
            print "$fg[red]    ⠀⠀⠀⠀⠀⠀⠀⠈⠉⠛⠛⠛⠛⠋⠉⠀⠀⠀⠀⠀  $reset_color"
            exit $es
            # aye '\(ˆ˚ˆ)/ <>_<> (-_- ;) ˚∆˚ Shiver me timbers, down to Davey Jones locker! Status:' $es; print; exit $es
        else
            aye "$fg[green]⚔⚔⚔ SURVIVAL! ⚔⚔⚔$reset_color" \
                "$fg[$units_color](⧖ ${tfinal}${units})$reset_color\n"
        fi
    done

    aye "$fg_bold[green]⚑⚑⚑ Ye survived the barrage. Musta been a fluke. ⚑⚑⚑$reset_color"
}

# Run a set of scripts based on which hook is active
select_hook() {
    case $active_githook in
        pre-commit)         run_scripts $pre_commit;         unset pre_commit ;;
        commit-msg)         run_scripts $commit_msg;         unset commit_msg ;;
        post-commit)        run_scripts $post_commit;        unset post_commit ;;
        prepare-commit-msg) run_scripts $prepare_commit_msg; unset prepare_commit_msg ;;
        post-checkout)      run_scripts $post_checkout;      unset post_checkout ;;
         # for alt tasks
        *)                  run_scripts $1 ;;
    esac }

### Main

print_banner
setup_changes

# aye "Loadin the whole ship’s arsenal to the gunwales: $captfile\n" # $PWD/$captfile\n
# Run team-wide repo hooks
runlevel=$captfile
source $captfile
select_hook

exit_gracefully() { aye $@; exit }
# exit_gracefully() { [[ -n $@ ]] && aye $@; exit }

# dbg "captfilelocal: $captfilelocal"
if [[ -f $captfilelocal ]]; then source $captfilelocal
else exit_gracefully "No captfilelocal found, so finishin now."; fi

dbg active_githook: $active_githook
# dbg post_checkout: $post_checkout
# eval "unset ${active_githook:gs/-/_}"
if [[ $active_githook == 'pre-commit'         && -z $pre_commit ]] ||
   [[ $active_githook == 'commit-msg'         && -z $commit_msg ]] ||
   [[ $active_githook == 'post-commit'        && -z $post_commit ]] ||
   [[ $active_githook == 'prepare-commit-msg' && -z $prepare_commit_msg ]] ||
   [[ $active_githook == 'post-checkout'      && -z $post_checkout ]]; then
    exit_gracefully
fi

# Optionally run user hooks if they exist
if [[ -f $captfilelocal ]]; then
    # Run user-local hooks
    # print
    # print "         \\"
    # print "         (o> "
    # print "      ___(()___"
    # print "         ||"
    # print
    # date
    # aye "Next on the plank: user-local hook scripts"
    # aye "Now loadin yer local muskets: $PWD/$captfilelocal\n"
    runlevel=$captfilelocal
    select_hook
fi

# Show successful completion
# print
# aye 'Show a leg!' # => wake up, we're done, succussfully!
