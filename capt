#! /bin/zsh

# capt: a very simple git-hook manager

# Symbols fer usin:  ⚔ ⚳ ⚑ ☁ ☀ ✓ ◴◵◶◷

# Built-in convenience checkers
# keys are for lookups
# values are an optional filter, followed by a command to run
typeset -A builtin_cannons=(
    'markdownlint' '(md|mkd|markdown)mdl'
    'cljlint'      '(clj|cljc|cljs)clj-kondo'
    # 'gommit'       'gommit check message "$(cat $1)"'
    'msglint'      'msglint "$(cat $GITARG1)"'
    'cljfmt'       '(clj)cljfmt check'
    'colorquote'   'colorquote'
)

typeset -A builtin_helps=(
    markdownlint 'Check markdown files for various conventional violations'
    cljlint 'Perform static analysis on Clojure/EDN files without the need of a running REPL'
    msglint 'Ensure a commit message adheres to a specied standard format'
    cljfmt 'Format clojure files'
)

if [[ $@[1] == 'help' ]]; then
    print 'capt is a git-hook manager'
    print
    print 'Detected your shared control file:' $CAPT_FILE
    [[ -f $CAPT_LOCALFILE ]] && print 'Detected your local personal control file:' $CAPT_LOCALFILE
    # print $builtin_helps
    # print ${builtin_helps[kondo]}
    print "\nBuilt-in slashers:"
    for b in ${(k)builtin_helps}; do printf '  %-16s%s\n' $b ${builtin_helps[$b]} ; done
    exit
fi

autoload colors; colors

# Save the incoming git-hook arg(s)
GITARG1=$argv[2] GITARG2=$argv[3] GITARG3=$argv[4]

# Use s* to mean "system" as in "sgrep" -> "system grep"
if [[ $OSTYPE == darwin* ]] ; then
    if ! type ggrep >/dev/null; then
        print 'Detected that GNU coreutils et al are not installed. You should run:'
        print 'brew install coreutils findutils gnu-tar gnu-sed gawk gnutls gnu-indent gnu-getopt grep'
        exit 1
    else
        sdate() { gdate $@ }
        sgrep() { ggrep $@ }
        ssed()  { gsed $@ }
        splayer() { afplay $@ }
    fi
else
    sdate() { date $@ }
    sgrep() { grep $@ }
    ssed()  { sed $@ }
    splayer() { play $@ }
fi

dbg() { [[ -n $CAPT_VERBOSE ]] && print "$fg[cyan]DEBUG:" $@ $reset_color }
# aye() { print '(◕‿-)' $@ }
aye()  { print "$fg_bold[blue](◕‿-)$reset_color" $@ }
ayen() { print -n "$fg_bold[blue](◕‿-)$reset_color" $@ } # no newline

reporoot=$(git rev-parse --show-toplevel 2>/dev/null)
if [[ $? -ne 0 ]]; then
    aye "Captain must be run from the root of a git repo."; exit 1
elif [[ $reporoot != $PWD ]]; then
    aye "Captain only runs from yer repo root: $reporoot"; exit 1
fi

if [[ $#@ < 1 ]]; then
    aye 'Captain needs an arrrg! Try passing a git-hook name, like "pre-commit".'; exit 1
fi

print_banner() {
    # print '(◕‿-) Shiver me timbers!'
    # print ""
    print
    # aye "$fg_bold[white][$(sdate +%T)] $fg_bold[blue]=== ${(U)active_githook} ===$reset_color ${bold_color}CAPTAIN IS OVERHAULIN. NO QUARTER!$reset_color"
    print -n "$fg_bold[blue](◕‿-)$reset_color" \
          "$fg_bold[blue]☠☠☠ ${(U)active_githook} ☠☠☠$reset_color" \
          "$fg_bold[white][◷ $(sdate +%T)]$reset_color"
    # aye "$bold_color=== ${(U)active_githook} ===$reset_color\n"
    # print '       _________ '
    # print '      |-_ .-. _-|'
    # print '      |  (*^*)  |'
    # print '      |_-"|H|"-_|'
    # print
}

hooksdir=${CAPT_HOOKSDIR-.git/hooks}
scriptsdir=${CAPT_SCRIPTSDIR-.capt/scripts}
# captfile=${CAPT_FILE-capt.zsh}
captfile=${CAPT_FILE-.capt/share.sh}
# captfilelocal=${CAPT_LOCALFILE-captlocal.zsh}
captfilelocal=${CAPT_LOCALFILE-.capt/local.sh}
path+=$scriptsdir

if [[ ! -f $captfile ]]; then print "Unable to load CAPT_FILE $captfile"; exit 1; fi

# FIXME This could possibly go into print_banner, if `source`ing run first,
# but unlikely since need to source both capt files
active_githook=$1
# aghu=$(ssed 's/-/_/g' <<<$active_githook)
# print aghu: $aghu
# [[ -n $"$(eval 'print $aghu')" ]] && print yes: $aghu || print no1
# [[ -n $"$aghu" ]] && print yes: $aghu || print no2
# if [[ -z $active_githook ]]; then
#     print "no hook configured in $captfile or $captfilelocal for $1"
#     # exit
# else
#     print "ok got an active_githook: $active_githook"
# fi

# Set up vars to be available in proj capt.zsh, print which files changed
setup_changes() {
    # VALUEADD Magic to figure out main v master and get changed files
    if [[ -z $CAPT_MAIN_BRANCH ]]; then
        # Fast and inaccurate https://stackoverflow.com/a/50056710/326516
        # main_branch=$(git branch | sgrep '*' | cut -f2 -d' ')
        # https://stackoverflow.com/a/42570510/326516
        # main_branch=$(git branch -r --points-at refs/remotes/origin/HEAD | sgrep '\->' | cut -d' ' -f5 | cut -d/ -f2)
        # https://stackoverflow.com/a/49384283/326516
        main_branch=$(git symbolic-ref --short refs/remotes/origin/HEAD | ssed 's@^origin/@@')
    fi
    if [[ ! $main_branch == (main|master) ]]; then
        # This approach is better but slow to reach remote so like to avoid
        aye "\nDiscoverin yer MAIN branch remotely, since couldn't determine locally."
        aye "You could set CAPT_MAIN_BRANCH to avoid the stall."
        # https://stackoverflow.com/a/67170894/326516SX
        aye "You should also run this registration since your repo is not a clone:"
        aye "git remote set-head origin -a"
        main_branch=$(git remote show origin | ssed -n '/HEAD branch/s/.*: //p')
    fi
    dbg "main_branch: $main_branch"
    # aye "Branch yer changes are bein compared against: $bold_color$main_branch$reset_color"
    print -n " $fg_bold[magenta][⎇ $main_branch]$reset_color"
    # CAPT_FILES_CHANGED=( $(git diff --name-only --cached origin/$main_branch) )
    CAPT_FILES_CHANGED_ORIG=( $(git diff --name-only --cached $main_branch) )
    CAPT_FILES_CHANGED=( $CAPT_FILES_CHANGED_ORIG )
    # aye "[Δ Staged files changed ($#CAPT_FILES_CHANGED)]: $bold_color$CAPT_FILES_CHANGED$reset_color"
    if (( $#CAPT_FILES_CHANGED > 0 )); then
        print " $fg_bold[yellow][Δ($#CAPT_FILES_CHANGED) $CAPT_FILES_CHANGED]$reset_color"
    else print; fi
    # for f in $CAPT_FILES_CHANGED; do aye "- $bold_color$f$reset_color"; done
    # print
}

# Run the scripts from control file
run_scripts () {
    # FIXME maybe all the vars (CAPT_FILES_CHANGED etc) should be local since getting reset on every call?
    # TODO check for existence of specified hook and print meaningful message if no/empty hook
    if [[ -z $@ ]]; then aye "No hooks to be run."; return; fi
    # Print out all the scripts about to be run
    executors=()
    for line in $@; do
        [[ $line == *:* ]] &&
            executors+="$fg_bold[grey]${${(@s/:/)line}[1]}$reset_color" ||
            executors+="$fg_bold[grey]$line$reset_color"
    done
    # print; aye "$fg_bold[cyan][$runlevel]$reset_color Execution awaits! $executors"
    # printf '\xc'; print "" # no luck with printing line for pagebreak/formfeed in magit
    print; aye "$fg_bold[cyan]☁☁☁ $runlevel ☁☁☁$reset_color $fg_bold[grey][⚳ $executors]$reset_color"

    # for line in $@; do
    #     [[ $line == *:* ]] &&
    #         aye "- $bold_color${${(@s/:/)line}[1]}$reset_color" ||
    #         aye "- $bold_color$line$reset_color"
    # done

    for line in $@; do
        # Reset for each time through
        CAPT_FILES_CHANGED=( $CAPT_FILES_CHANGED_ORIG )
        dbg xxx CAPT_FILES_CHANGED: $CAPT_FILES_CHANGED
        inv=( ${(@s: :)line} ) # split on spaces to get first, discard beyond second
        name=$inv[1]
        script=$inv[2]
        cmd=${line#* } # remove up to first space, keeping all the rest
        dbg "inv:" $inv[1] "::" $inv[2] "::" $inv[3] "::"
        cmd0=${cmd%% *} # keep only first part, the command name
        dbg "line: $line :: cmd0: $cmd0 :: cmd: $cmd"

        # Built-in has filter already, or specified filter
        # print_name=$(ssed 's/[:(].*//' <<<$name)
        print_name=$(print $name | ssed 's/[:(].*//' )
        # print
        ayen "$fg[yellow]⚳⚳⚳ ${(U)print_name} ⚳⚳⚳$reset_color"
        if [[ ! $name == *: ]]; then dbg "built-in plain checker with no spec:" $name
            # Need to fix up cmd since no spec, and maybe include filtered files
            script=$inv[1]
            just_buitins=${(k)builtin_cannons}
            if ! (($just_buitins[(Ie)$name])); then
                print; aye "$fg[red]ERROR: Unable to find built-in: $bold_color$name$reset_color" ; exit 1
            fi
            #              NAME        FILTER    CMD
            # User spec is like:    markdownlint(md|mkd): mdl ...
            # DSL is actually like: (md|mkd)mdl ...
            dsl=$builtin_cannons[$name]
            filter=$(print $dsl | ssed 's/).*/)/')
            # print xxx $filter
            # non-greedy, just the very first part up to (, and remove ending arg(s)
            cmd=$(print $dsl | ssed -r -e 's/^\([^)]+\)//')
            cmd0=$(print $cmd | ssed -r 's/ .*//')
            dbg "cmd0: "$cmd0
            # Many antics follow to handle filters and changes for built-ins
            if [[ $filter != '('* ]]; then filtered_files=( $CAPT_FILES_CHANGED )
            else                           filtered_files=( $(print -l $CAPT_FILES_CHANGED | sgrep -E "\.$filter") ); fi
            # TODO Add more! Special casing for specific hooks needing special treatment
            if [[ $active_githook =~ 'commit-msg' ]]; then
                print
            elif [[ $#filtered_files < 1 ]]; then
                if [[ -z $CAPT_FILES_CHANGED ]]; then :
                else print " (Not seein any matchin files staged, skippin.)"
                     continue
                fi
            else
                cmd="$cmd0 $filtered_files"
                # print; aye "Filtered files under siege:" $#filtered_files
                print " $fg[yellow][$filtered_files]$reset_color"
                dbg "files:" $filtered_files
                # aye "Ahoy! Aimin the captain’s built-in $print_name: $bold_color$cmd$reset_color"
                aye "▶ $bold_color$cmd$reset_color"
            fi
        elif [[ $name == *\(*\)* ]]; then dbg "filtered checker"
            filter=$(print $name | ssed 's/.*(/(/;s/://') # remove front name and trailing :
            dbg filter: $filter
            dbg CAPT_FILES_CHANGED: $CAPT_FILES_CHANGED
            filtered_files=( $(print -l $CAPT_FILES_CHANGED | sgrep -E "\.$filter") )
            CAPT_FILES_CHANGED=( $filtered_files )
            if [[ $#filtered_files < 1 ]]; then print " (Not seein any matchin files staged, skippin.)"; continue
            else
                # print; aye "Filtered files under siege:" $#filtered_files
                print " $fg[yellow][$filtered_files]$reset_color"
                dbg "files:" $filtered_files
                # aye "Blimey! Aimin yer custom-rigged $print_name: $bold_color$cmd$reset_color"
                aye "▶ $bold_color$cmd$reset_color"
            fi
        elif [[ $line == *CAPT_FILES_CHANGED* || ! $name == *: ]]; then dbg "unfiltered checker"
            filtered_files=( $CAPT_FILES_CHANGED )
            if [[ $#filtered_files < 1 ]]; then print " (Not seein any matchin files staged, skippin.)"; continue
            else
                # print; aye "Files under siege:" $#CAPT_FILES_CHANGED
                print " $fg[yellow][$CAPT_FILES_CHANGED]$reset_color"
                dbg "files:" $CAPT_FILES_CHANGED
                # aye "Aimin yer cutlass $print_name with yer files: $bold_color$cmd$reset_color"
                aye "▶ $bold_color$cmd$reset_color"
            fi
        else
            # print; aye "Ye took care of file selection yerself, or no files needin fer sayin."
            print " $fg[yellow][∞]$reset_color"
            # aye "Doubloons! Aimin yer $print_name: $bold_color$cmd$reset_color"
            aye "▶ $bold_color$cmd$reset_color"
        fi

        # Add args to pass from git if it's one of the arg-accepting hooks
        # [[ $active_githook =~ 'commit-msg' ]] && cmd+=' $1 $2'
        t0=$(sdate +%s%3N) # start timer
        # Work with either a local script or something found on path
        dbg "cmd: $cmd, cmd0: $cmd0"
        dbg "script: $scriptsdir/$script"
        # Try to find script or command
        if [[ -f $scriptsdir/$script ]]; then eval $scriptsdir/$cmd
        elif type $cmd0 >/dev/null;      then eval $cmd
        # Just skip this one hook if command not found
        else aye "$fg[red]WARNING: Skippin on yer $print_name; $cmd0 and $script be lost at sea.$reset_color"
        fi
        es=$?
        wait # don't process until background scripts are finished
        tfinal=$(( $(sdate +%s%3N) - $t0 )) units=ms units_color=white
        if (( 1000 < $tfinal )); then tfinal=$(( $tfinal / 1000 )); units=s; units_color=red; fi
        # Bail out on whole run if any script not successful
        if [[ $es -ne 0 ]]; then
            print
            # print "$fg[red]    ⠀⠀⠀⠀⠀⠀⠀⠀⣀⣤⣤⣤⣤⣀⡀⠀⠀⠀⠀⠀⠀⠀"
            # print "$fg[red]    ⠀⠀⠀⠀⠀⢀⣴⣿⣿⣿⡿⢿⣿⣿⣿⣷⣄⠀⠀⠀⠀⠀"
            # print "$fg[red]    ⠀⣠⣤⣶⣶⣿⣿⣿⣿⣯⠀⠀⣽⣿⣿⣿⣿⣷⣶⣤⣄⠀"
            # print "$fg[red]    ⢸⣿⣿⣿⣿⣿⣿⣿⣿⡅⠉⠉⢨⣿⣿⣿⣿⣿⣿⣿⣿⡇"
            # print "$fg[red]    ⠈⠻⣿⣿⣿⣿⣿⣿⣿⣥⣴⣦⣬⣿⣿⣿⣿⣿⣿⣿⠟⠁"
            # print "$fg[red]    ⠀⠀⢸⣿⡿⠿⠿⠿⠿⠿⠿⠿⢿⣿⣿⣿⠿⢿⣿⡇⠀⠀"
            # print "$fg[red]    ⠀⣠⣾⣿⠂⠀⠀⣤⣄⠀⠀⢰⣿⣿⣿⣿⡆⠐⣿⣷⣄⠀"
            # print "$fg[red]    ⠀⣿⣿⡀⠀⠀⠈⠿⠟⠀⠀⠈⠻⣿⣿⡿⠃⠀⢀⣿⣿⠀"
            # print "$fg[red]    ⠀⠘⠻⢿⣷⡀⠀⠀⠀⢀⣀⣀⠀⠀⠀⠀⢀⣾⡿⠟⠃⠀"
            # print "$fg[red]    ⠀⠀⠀⠸⣿⣿⣷⣦⣾⣿⣿⣿⣿⣦⣴⣾⣿⣿⡇⠀⠀⠀Down to Davey Jones’ locker!"
            # print "$fg[red]    ⠀⠀⠀⠀⢻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠀⠀⠀⠀Status: $es"
            # print "$fg[red]    ⠀⠀⠀⠀⠈⠻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠟⠁⠀⠀⠀⠀"
            # print "$fg[red]    ⠀⠀⠀⠀⠀⠀⠀⠈⠉⠛⠛⠛⠛⠋⠉⠀⠀⠀⠀⠀⠀⠀"
            print "$fg[red]         "'\\\\'
            print "$fg[red]         (o>     Down to Davey Jones’ locker!"
            print "$fg[red]      ___(()___  Status $es"
            print "$fg[red]         ||"
            print "$reset_color"
            exit $es
            # aye '\(ˆ˚ˆ)/ <>_<> (-_- ;) ˚∆˚ Shiver me timbers, down to Davey Jones locker! Status:' $es; print; exit $es
        else
            aye "$fg[green]⚔⚔⚔ SURVIVAL! ⚔⚔⚔$reset_color" \
                "$fg[$units_color](⧖ ${tfinal}${units})$reset_color\n"
        fi
    done

    aye "$fg_bold[green]⚑⚑⚑ Ye survived the barrage. Musta been a fluke. ⚑⚑⚑ $reset_color"
}

# Run a set of scripts based on which hook is active

select_hook() {
    case $active_githook in
        pre-commit)         run_scripts $pre_commit;         unset pre_commit ;;
        commit-msg)         run_scripts $commit_msg;         unset commit_msg ;;
        post-commit)        run_scripts $post_commit;        unset post_commit ;;
        prepare-commit-msg) run_scripts $prepare_commit_msg; unset prepare_commit_msg ;;
        post-checkout)      run_scripts $post_checkout;      unset post_checkout ;;
         # for alt tasks
        *)                  run_scripts $1 ;;
    esac }

### Main

print_banner
setup_changes

# aye "Loadin the whole ship’s arsenal to the gunwales: $captfile\n" # $PWD/$captfile\n
# Run team-wide repo hooks
runlevel=$captfile
source $captfile
select_hook

# exit_gracefully() { aye $@; exit }
exit_gracefully() { if (( $#@ > 0 )); then print; aye $@; fi; exit }

# dbg "captfilelocal: $captfilelocal"
if [[ -f $captfilelocal ]]; then source $captfilelocal
else exit_gracefully "No captfilelocal found, so finishin now."; fi

dbg active_githook: $active_githook
# dbg post_checkout: $post_checkout
# eval "unset ${active_githook:gs/-/_}"
if [[ $active_githook == 'pre-commit'         && -z $pre_commit ]] ||
   [[ $active_githook == 'commit-msg'         && -z $commit_msg ]] ||
   [[ $active_githook == 'post-commit'        && -z $post_commit ]] ||
   [[ $active_githook == 'prepare-commit-msg' && -z $prepare_commit_msg ]] ||
   [[ $active_githook == 'post-checkout'      && -z $post_checkout ]]; then
    exit_gracefully
fi

# Optionally run user hooks if they exist
if [[ -f $captfilelocal ]]; then
    # Run user-local hooks
    # print
    # print "         \\"
    # print "         (o> "
    # print "      ___(()___"
    # print "         ||"
    # print
    # date
    # aye "Next on the plank: user-local hook scripts"
    # aye "Now loadin yer local muskets: $PWD/$captfilelocal\n"
    runlevel=$captfilelocal
    select_hook
fi

# Show successful completion
# print
# aye 'Show a leg!' # => wake up, we're done, succussfully!
